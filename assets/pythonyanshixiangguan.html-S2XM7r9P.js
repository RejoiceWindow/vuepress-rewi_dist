import{_ as n,o as s,c as e,a as t}from"./app-De5JuplM.js";const a={},l=t(`<p><code>time.perf_counter()</code> 和 <code>select.select()</code> 都是用于精确测量时间或控制延时的工具，但它们的工作原理和精度是不同的，适用于不同的场景。下面我们详细对比一下这两个方法的精度、用途和适用场景。</p><h3 id="_1-time-perf-counter" tabindex="-1"><a class="header-anchor" href="#_1-time-perf-counter"><span>1. <strong><code>time.perf_counter()</code></strong></span></a></h3><p><code>time.perf_counter()</code> 是 Python 中的高精度计时器，用于获取当前的时间戳。它的主要用途是测量时间间隔，并且具有最高的精度。</p><ul><li><strong>精度</strong>：<code>perf_counter()</code> 提供的是一个高精度的计时器，通常精度在微秒甚至更高（具体精度取决于操作系统和硬件）。</li><li><strong>用途</strong>：用于性能测试、测量时间间隔和高精度定时。它并不执行延时，只是用来获取当前时间。</li><li><strong>特点</strong>： <ul><li>精度通常是微秒级别或更高，适合高精度的时间间隔测量。</li><li>它是单向计时（即从某个固定的参考点开始递增），适合用作计算程序运行时间。</li><li>它并不用于实现延时或等待操作。</li></ul></li></ul><p><strong>示例</strong>：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre class="language-python"><code><span class="line"><span class="token keyword">import</span> time</span>
<span class="line"></span>
<span class="line">start <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 等待 1 秒</span></span>
<span class="line">end <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;Elapsed time: </span><span class="token interpolation"><span class="token punctuation">{</span>end <span class="token operator">-</span> start<span class="token punctuation">}</span></span><span class="token string"> seconds&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-select-select" tabindex="-1"><a class="header-anchor" href="#_2-select-select"><span>2. <strong><code>select.select()</code></strong></span></a></h3><p><code>select.select()</code> 是用于多路复用（I/O）操作的系统调用，常用于监控多个文件描述符的状态变化，也可以用来实现延时（等待一段时间）。</p><ul><li><strong>精度</strong>：<code>select.select()</code> 在指定的时间内等待文件描述符准备就绪，它接受一个超时时间参数，这个超时时间的精度通常在毫秒级别（通常较粗糙）。精度受限于操作系统的调度机制和文件描述符的状态变化。</li><li><strong>用途</strong>：主要用于 I/O 多路复用，等待某个或多个文件描述符变得可读、可写或发生异常。也常用于延时操作，在没有 I/O 操作时可以用来模拟延时。</li><li><strong>特点</strong>： <ul><li>当没有 I/O 操作时，<code>select.select()</code> 可以用来等待一段时间，超时会触发返回，适用于等待事件发生的场景。</li><li>它的精度和延时的实际时间通常取决于操作系统的调度机制，尤其是当延时时间较短时，实际延时可能会比指定的时间稍长。</li></ul></li></ul><p><strong>示例</strong>：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py" data-title="py"><pre class="language-python"><code><span class="line"><span class="token keyword">import</span> select</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 阻塞 1 秒</span></span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Starting wait...&quot;</span><span class="token punctuation">)</span></span>
<span class="line">select<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 等待 1 秒</span></span>
<span class="line"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;1 second elapsed.&quot;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span>比较：</span></a></h3><table><thead><tr><th>特性</th><th><code>time.perf_counter()</code></th><th><code>select.select()</code></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>获取高精度时间戳，测量时间间隔</td><td>I/O 多路复用、延时等待</td></tr><tr><td><strong>精度</strong></td><td>微秒级甚至更高，操作系统和硬件决定精度</td><td>毫秒级精度，受限于操作系统调度和文件描述符状态</td></tr><tr><td><strong>延时实现</strong></td><td>只能用来测量时间间隔，不适合直接实现延时</td><td>可用作延时等待，但不适合高精度延时</td></tr><tr><td><strong>适用场景</strong></td><td>性能测试、时间间隔计算、事件计时</td><td>I/O 等待、轻量级延时等待</td></tr></tbody></table><h3 id="哪个更精确" tabindex="-1"><a class="header-anchor" href="#哪个更精确"><span>哪个更精确？</span></a></h3><ul><li><strong><code>time.perf_counter()</code></strong> 提供更高的精度，尤其适用于时间间隔测量。它的精度通常是微秒级别（或更高），而且它不受操作系统调度的影响，适合用于性能测试和高精度的定时任务。</li><li><strong><code>select.select()</code></strong> 适用于 I/O 等待或轻量级的阻塞延时，但其延时精度通常较粗，约在毫秒级。延时精度受操作系统调度和文件描述符的状态变化影响，因此并不适合用于高精度的延时。</li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结：</span></a></h3><ul><li>如果你的目标是 <strong>高精度的时间测量</strong> 或 <strong>精确的时间间隔</strong>，推荐使用 <strong><code>time.perf_counter()</code></strong>。</li><li>如果你需要在没有 I/O 操作的情况下实现 <strong>阻塞延时</strong>，并且不要求极高的精度，可以使用 <strong><code>select.select()</code></strong>，尤其是在需要监控文件描述符的同时进行延时等待时。</li></ul>`,17),o=[l];function c(p,i){return s(),e("div",null,o)}const d=n(a,[["render",c],["__file","pythonyanshixiangguan.html.vue"]]),u=JSON.parse('{"path":"/blogs/developer/python/pythonyanshixiangguan.html","title":"python延时相关","lang":"zh-CN","frontmatter":{"title":"python延时相关","date":"2024-11-27T08:36:33.000Z","password":["5cde5596ace9b1e212ab3ace1f083815","a5db2fd9def8a592756d4ca2b5301c20"],"hideComments":false},"headers":[{"level":3,"title":"1. time.perf_counter()","slug":"_1-time-perf-counter","link":"#_1-time-perf-counter","children":[]},{"level":3,"title":"2. select.select()","slug":"_2-select-select","link":"#_2-select-select","children":[]},{"level":3,"title":"比较：","slug":"比较","link":"#比较","children":[]},{"level":3,"title":"哪个更精确？","slug":"哪个更精确","link":"#哪个更精确","children":[]},{"level":3,"title":"小结：","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1732772000000,"updatedTime":1744078224000,"contributors":[{"name":"ReWi","email":"RejoiceWindow@yeah.net","commits":3},{"name":"ReWi","email":"RejoiceWindow@yeah.com","commits":2}]},"filePathRelative":"blogs/developer/python/python延时相关.md"}');export{d as comp,u as data};
