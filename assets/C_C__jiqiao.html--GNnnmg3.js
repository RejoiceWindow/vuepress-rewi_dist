import{_ as r,c as t,a as l,b as n,e as s,d as i,r as d,o}from"./app-C5EA9484.js";const p="/assets/C_C__001-XdxDBmSJ.png",c={},u={href:"https://blog.csdn.net/seven_feifei/article/details/95947358",target:"_blank",rel:"noopener noreferrer"},m={href:"https://blog.csdn.net/lsllll44/article/details/111711344",target:"_blank",rel:"noopener noreferrer"},f={href:"https://gitee.com/testzyh/notes/blob/master/%E8%BD%AC%E8%BD%BD%E4%B8%8E%E6%94%B6%E8%97%8F/%E6%96%87/Computer%20Systems%20A%20Programmer%E2%80%99s%20Perspective.md#71-%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/jackchoise030/article/details/88560912",target:"_blank",rel:"noopener noreferrer"},h={href:"https://blog.csdn.net/qingzhuyuxian/article/details/80968135",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/DaMercy/article/details/109078274",target:"_blank",rel:"noopener noreferrer"},v={href:"https://baijiahao.baidu.com/s?id=1729374634493915166&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"},C={href:"https://wenku.baidu.com/view/96770f4b1db91a37f111f18583d049649b660e0d.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://baijiahao.baidu.com/s?id=1729374634493915166&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"};function x(E,e){const a=d("ExternalLinkIcon");return o(),t("div",null,[e[21]||(e[21]=l(`<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">修改记录：</span>
<span class="line">V0.0.0  创建日期：2022.10.31</span>
<span class="line">V0.0.1  增加日期：2022.10.31 定位程序运行时的错误</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="attribute之-section-详解" tabindex="-1"><a class="header-anchor" href="#attribute之-section-详解"><span><strong>attribute</strong>之 section 详解</span></a></h1>`,2)),n("p",null,[n("a",u,[e[0]||(e[0]=s("https://blog.csdn.net/seven_feifei/article/details/95947358",-1)),i(a)])]),e[22]||(e[22]=n("h1",{id:"c-语言-一些特殊的用法-函数调度表、变量附加属性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#c-语言-一些特殊的用法-函数调度表、变量附加属性"},[n("span",null,"C 语言---一些特殊的用法（函数调度表、变量附加属性）")])],-1)),n("p",null,[n("a",m,[e[1]||(e[1]=s("https://blog.csdn.net/lsllll44/article/details/111711344",-1)),i(a)]),n("a",f,[e[2]||(e[2]=s("https://gitee.com/testzyh/notes/blob/master/转载与收藏/文/Computer Systems A Programmer’s Perspective.md#71-编译器驱动",-1)),i(a)])]),e[23]||(e[23]=n("h1",{id:"一、定位程序运行时的错误",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#一、定位程序运行时的错误"},[n("span",null,"一、定位程序运行时的错误")])],-1)),n("p",null,[e[5]||(e[5]=s("参考： ",-1)),n("a",g,[e[3]||(e[3]=s("https://blog.csdn.net/jackchoise030/article/details/88560912",-1)),i(a)]),e[6]||(e[6]=s(" 参考：",-1)),n("a",h,[e[4]||(e[4]=s("https://blog.csdn.net/qingzhuyuxian/article/details/80968135",-1)),i(a)]),e[7]||(e[7]=s(" C/C++提供了三个宏",-1)),e[8]||(e[8]=n("strong",null,"FUNCTION",-1)),e[9]||(e[9]=s(",",-1)),e[10]||(e[10]=n("em",null,"FILE",-1)),e[11]||(e[11]=s("和",-1)),e[12]||(e[12]=n("em",null,"LINE",-1)),e[13]||(e[13]=s("定位程序运行时的错误。程序预编译时预编译器将用所在的函数名，文件名和行号替换。",-1))]),e[24]||(e[24]=l(`<h1 id="宏定义" tabindex="-1"><a class="header-anchor" href="#宏定义"><span>宏定义</span></a></h1><h2 id="function" tabindex="-1"><a class="header-anchor" href="#function"><span><strong>FUNCTION</strong></span></a></h2><p>另外 gcc 还支持<strong>func</strong>,它指示所在的函数，但是这个关键字不被 windows 下的 vc6.0 支持</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#include &lt;stdio.h&gt;</span>
<span class="line">void main()</span>
<span class="line">{</span>
<span class="line">printf(&quot;this is print by function %s\\n&quot;,__func__);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="file" tabindex="-1"><a class="header-anchor" href="#file"><span><strong>FILE</strong></span></a></h2><p>C 语言中的<strong>FILE</strong>用以指示本行语句所在源文件的文件名</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#include &lt;stdio.h&gt;</span>
<span class="line">int main()</span>
<span class="line">{</span>
<span class="line">printf(&quot;%s\\n&quot;,__FILE__);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="line" tabindex="-1"><a class="header-anchor" href="#line"><span><strong>LINE</strong></span></a></h2><p>在 linux 用 gcc 编译，在 windows 的 vc6.0 下编译都可以通过， 可以通过语句#line 来重新设定<strong>LINE</strong>的值</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#include &lt;stdio.h&gt;</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">#line 200  //指定下一行的__LINE__为200</span>
<span class="line">main()</span>
<span class="line">{</span>
<span class="line">printf(&quot;%d\\n&quot;,__LINE__);</span>
<span class="line">printf(&quot;%d\\n&quot;,__LINE__);</span>
<span class="line">printf(&quot;%d\\n&quot;,__LINE__);</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="预编译指令" tabindex="-1"><a class="header-anchor" href="#预编译指令"><span>预编译指令</span></a></h1>`,11)),n("p",null,[e[16]||(e[16]=s("在 C/C++中，在使用预编译指令#include 的时候，为了防止重复引用造成二义性，通常有两种方式—— 第一种是#ifndef 指令防止代码块重复引用，第二种就是#pragma once 指令，在想要保护的文件开头写入。 参考：",-1)),n("a",b,[e[14]||(e[14]=s("https://blog.csdn.net/DaMercy/article/details/109078274",-1)),i(a)]),e[17]||(e[17]=s("? ",-1)),n("a",v,[e[15]||(e[15]=s("https://baijiahao.baidu.com/s?id=1729374634493915166&wfr=spider&for=pc",-1)),i(a)])]),e[25]||(e[25]=l('<h2 id="pragma-once" tabindex="-1"><a class="header-anchor" href="#pragma-once"><span>#pragma once</span></a></h2><p>并不是 C++的原生语法,而是编译器的一种支持,所以并不是所有的编译器都能够支持。#ifndef 则为 C++的标准。</p><h1 id="pragma-once-一般由编译器提供保证-同一个文件不会被包含多次。这里所说的-同一个文件-是指物理上的一个文件-而不是指内容相同的两个文件。无法对一个头文件中的一段代码作-pragma-once-声明-而只能针对文件。此方式不会出现宏名碰撞引发的奇怪问题-大型项目的编译速度也因此提供了一些。缺点是如果某个头文件有多份拷贝-此方法不能保证它们不被重复包含。在-c-c-中-pragma-once-是一个非标准但是被广泛支持的方式" tabindex="-1"><a class="header-anchor" href="#pragma-once-一般由编译器提供保证-同一个文件不会被包含多次。这里所说的-同一个文件-是指物理上的一个文件-而不是指内容相同的两个文件。无法对一个头文件中的一段代码作-pragma-once-声明-而只能针对文件。此方式不会出现宏名碰撞引发的奇怪问题-大型项目的编译速度也因此提供了一些。缺点是如果某个头文件有多份拷贝-此方法不能保证它们不被重复包含。在-c-c-中-pragma-once-是一个非标准但是被广泛支持的方式"><span>pragma once 一般由编译器提供保证：同一个文件不会被包含多次。这里所说的”同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once 声明，而只能针对文件。此方式不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度也因此提供了一些。缺点是如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。在 C/C++中，#pragma once 是一个非标准但是被广泛支持的方式</span></a></h1><h1 id="pragma-once-方式产生于-ifndef-之后。-ifndef-方式受-c-c-语言标准的支持-不受编译器的任何限制-而-pragma-once-方式有些编译器不支持-较老编译器不支持-如-gcc-3-4-版本之前不支持-pragmaonce-兼容性不够好。-ifndef-可以针对一个文件中的部分代码-而-pragma-once-只能针对整个文件。相对而言-ifndef-更加灵活-兼容性好-pragma-once-操作简单-效率高" tabindex="-1"><a class="header-anchor" href="#pragma-once-方式产生于-ifndef-之后。-ifndef-方式受-c-c-语言标准的支持-不受编译器的任何限制-而-pragma-once-方式有些编译器不支持-较老编译器不支持-如-gcc-3-4-版本之前不支持-pragmaonce-兼容性不够好。-ifndef-可以针对一个文件中的部分代码-而-pragma-once-只能针对整个文件。相对而言-ifndef-更加灵活-兼容性好-pragma-once-操作简单-效率高"><span>pragma once 方式产生于#ifndef 之后。#ifndef 方式受 C/C++语言标准的支持，不受编译器的任何限制；而#pragma once 方式有些编译器不支持(较老编译器不支持，如 GCC 3.4 版本之前不支持#pragmaonce)，兼容性不够好。#ifndef 可以针对一个文件中的部分代码，而#pragma once 只能针对整个文件。相对而言，#ifndef 更加灵活，兼容性好，#pragma once 操作简单，效率高</span></a></h1><h2 id="ifndef" tabindex="-1"><a class="header-anchor" href="#ifndef"><span>#ifndef</span></a></h2><h1 id="ifndef-方式是-c-c-语言的标准支持-也是比较常用的方式-ifndef-的方式依赖于自定义的宏名-例中的-code-block-不能冲突-它不光可以保证同一份文件不会被包含两次-也能够保证不同文件完全相同的内容不会被包含两次。但-同样的-如果自定义的宏名不小心-重名-了-两份不同的文件使用同一个宏名进行-ifndef-那么会导致编译器找不到声明的情况-被编译器判定为重定义而屏蔽了" tabindex="-1"><a class="header-anchor" href="#ifndef-方式是-c-c-语言的标准支持-也是比较常用的方式-ifndef-的方式依赖于自定义的宏名-例中的-code-block-不能冲突-它不光可以保证同一份文件不会被包含两次-也能够保证不同文件完全相同的内容不会被包含两次。但-同样的-如果自定义的宏名不小心-重名-了-两份不同的文件使用同一个宏名进行-ifndef-那么会导致编译器找不到声明的情况-被编译器判定为重定义而屏蔽了"><span>ifndef 方式是 C/C++语言的标准支持，也是比较常用的方式，#ifndef 的方式依赖于自定义的宏名（例中的_CODE_BLOCK）不能冲突，它不光可以保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次。但，同样的，如果自定义的宏名不小心“重名”了，两份不同的文件使用同一个宏名进行#ifndef，那么会导致编译器找不到声明的情况（被编译器判定为重定义而屏蔽了）</span></a></h1><p>此外，由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef 会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once 的方式（Visual Studio 2017 新建头文件会自带#pragma once 指令）。</p><h1 id="二、-、-连接-字符串-代码" tabindex="-1"><a class="header-anchor" href="#二、-、-连接-字符串-代码"><span>二、 #、## 连接 字符串/代码</span></a></h1>',8)),n("p",null,[e[20]||(e[20]=s("参考：",-1)),n("a",C,[e[18]||(e[18]=s("https://wenku.baidu.com/view/96770f4b1db91a37f111f18583d049649b660e0d.html",-1)),i(a)]),n("a",_,[e[19]||(e[19]=s("https://baijiahao.baidu.com/s?id=1729374634493915166&wfr=spider&for=pc",-1)),i(a)])]),e[26]||(e[26]=l(`<h2 id="_1" tabindex="-1"><a class="header-anchor" href="#_1"><span>1</span></a></h2><p>When you put a # before an argument in a preprocessor macro, the preprocessor turns that argument into a character array. 在一个宏中的参数前面使用一个#，预处理器会把这个参数转换为一个字符数组 简化理解: #是“字符串化&quot;的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#define ERROR_LOG(module) fprintf(stderr,&quot; error: &quot;#module&quot;&quot;n&quot;)</span>
<span class="line"></span>
<span class="line">// ERROR_LOG(&quot;add&quot;); 转换为 fprintf(stderr, &quot;error: &quot;add&quot;\\n&quot;);</span>
<span class="line">// ERROR_LOG(devied =O); 转换为 fprintf(stderr,&quot; error: devied=0\\n&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2" tabindex="-1"><a class="header-anchor" href="#_2"><span>2</span></a></h2><p>“##&quot;是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。 在普通的宏定义中，预处理器一般把空格解释成分段标志，对于每一段和前面比较，相同的就被替换。但是这样做的结果是，被替换段之间存在一些空格。如果我们不希望出现这些空格，就可以通过添加一些#来替代空格。 三、宏定义 do{}while(0) 的作用 (1)空的宏定义避免 warning:</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#define foo() do{}while(0)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(2)存在一个独立的 block，可以用来进行变量定义，进行比较复杂的实现。 (3)如果出现在判断语句过后的宏,这样可以保证作为一个整体来是实现</p><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C" data-title="C"><pre><code><span class="line">#define foo(x) \\</span>
<span class="line">action1();</span>
<span class="line">action2();</span>
<span class="line">//在以下情况下:</span>
<span class="line">if(NULL== pPointer)</span>
<span class="line">foo();</span>
<span class="line">//就会出现 action1 和 action2 不会同时被执行的情况,而这显然不是程序设计的目的。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+p+'" width="600">',9))])}const k=r(c,[["render",x]]),L=JSON.parse('{"path":"/blogs/developer/C_C__/C_C__jiqiao.html","title":"C_C++技巧","lang":"zh-CN","frontmatter":{"title":"C_C++技巧","date":"2024-07-22T10:30:00.000Z","tags":["编程技巧"],"categories":["C_C++"]},"headers":[{"level":2,"title":"FUNCTION","slug":"function","link":"#function","children":[]},{"level":2,"title":"FILE","slug":"file","link":"#file","children":[]},{"level":2,"title":"LINE","slug":"line","link":"#line","children":[]},{"level":2,"title":"#pragma once","slug":"pragma-once","link":"#pragma-once","children":[]},{"level":2,"title":"#ifndef","slug":"ifndef","link":"#ifndef","children":[]},{"level":2,"title":"1","slug":"_1","link":"#_1","children":[]},{"level":2,"title":"2","slug":"_2","link":"#_2","children":[]}],"git":{"createdTime":1759387174000,"updatedTime":1769075498000,"contributors":[{"name":"ReWi","email":"RejoiceWindow@yeah.com","commits":3}]},"filePathRelative":"blogs/developer/C_C++/C_C++技巧.md"}');export{k as comp,L as data};
